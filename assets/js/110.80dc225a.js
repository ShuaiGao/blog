(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{438:function(t,i,s){"use strict";s.r(i);var l=s(4),v=Object(l.a)({},(function(){var t=this,i=t._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("p",[t._v("C++的初始化方法很多，各种初始化方法有一些不同。")]),t._v(" "),i("ol",[i("li",[t._v("vector"),i("int",[t._v(" ilist1;")])],1)]),t._v(" "),i("p",[t._v("默认初始化，vector 为空， size 为 0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。这种初始化方式适用于元素个数未知，需要在程序中动态添加的情况。")]),t._v(" "),i("ol",{attrs:{start:"2"}},[i("li",[t._v("vector"),i("int",[t._v(" ilist2(ilist);\nvector"),i("int",[t._v(" ilist2 = ilist;")])],1)],1)]),t._v(" "),i("p",[t._v("两种方式等价 ，ilist2 初始化为 ilist 的拷贝，ilist 必须与 ilist2 类型相同，也就是同为 int 的 vector 类型，ilist2 将具有和 ilist 相同的容量和元素")]),t._v(" "),i("ol",{attrs:{start:"3"}},[i("li",[t._v("vector"),i("int",[t._v(" ilist = {1,2,3.0,4,5,6,7};\nvector"),i("int",[t._v(" ilist {1,2,3.0,4,5,6,7};")])],1)],1)]),t._v(" "),i("p",[t._v("ilist 初始化为列表中元素的拷贝，列表中元素必须与 ilist 的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换。")]),t._v(" "),i("ol",{attrs:{start:"4"}},[i("li",[t._v("vector"),i("int",[t._v(" ilist3(ilist.begin()+2,ilist.end()-1);")])],1)]),t._v(" "),i("p",[t._v("ilist3 初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与 ilist3 的元素类型相容，在本例中 ilist3 被初始化为{3,4,5,6}。注意：由于只要求范围中的元素类型与待初始化的容器的元素类型相容，因此迭代器来自不同的容器是可能的，例如，用一个 double 的 list 的范围来初始化 ilist3 是可行的。另外由于构造函数只是读取范围中的元素进行拷贝，因此使用普通迭代器还是 const 迭代器来指出范围并没有区别。这种初始化方法特别适合于获取一个序列的子序列。")]),t._v(" "),i("ol",{attrs:{start:"5"}},[i("li",[t._v("vector"),i("int",[t._v(" ilist4(7);")])],1)]),t._v(" "),i("p",[t._v("默认值初始化，ilist4 中将包含 7 个元素，每个元素进行缺省的值初始化，对于 int，也就是被赋值为 0，因此 ilist4 被初始化为包含 7 个 0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。")]),t._v(" "),i("ol",{attrs:{start:"6"}},[i("li",[t._v("vector"),i("int",[t._v(" ilist5(7,3);")])],1)]),t._v(" "),i("p",[t._v("指定值初始化，ilist5 被初始化为包含 7 个值为 3 的 int")]),t._v(" "),i("ol",{attrs:{start:"7"}},[i("li",[t._v("int int_arr={1,2,3,4,5};\nvector"),i("int",[t._v(" ivec(begin(int_arr), end(int_arr));")])],1)])])}),[],!1,null,null,null);i.default=v.exports}}]);