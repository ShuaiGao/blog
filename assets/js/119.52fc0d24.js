(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{444:function(e,t,a){"use strict";a.r(t);var n=a(4),i=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("ECMA")]),e._v(" "),t("h1",{attrs:{id:"common-anguage-infrastructure-cli"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#common-anguage-infrastructure-cli"}},[e._v("#")]),e._v(" Common anguage Infrastructure(CLI)")]),e._v(" "),t("p",[e._v("Partition I:\nConcepts and Architecture")]),e._v(" "),t("h1",{attrs:{id:"通用语言基础设施"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通用语言基础设施"}},[e._v("#")]),e._v(" 通用语言基础设施")]),e._v(" "),t("p",[e._v("第一部分：")]),e._v(" "),t("p",[e._v("概念和架构")]),e._v(" "),t("h2",{attrs:{id:"foreword"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#foreword"}},[e._v("#")]),e._v(" Foreword")]),e._v(" "),t("p",[e._v("This fifth edition cancels and replaces the fourth edition. Changes from the previous edition( and thus also ISO/IEC 23271:2006) were made to enhance and update this Standard.")]),e._v(" "),t("p",[e._v("本第五版取消并代替第四版。 对上一版本（以及 ISO/IEC 23271:2006）进行了更改以增强和更新本标准。")]),e._v(" "),t("p",[e._v("The Following features hace been added, extended or clarified in the Standard:")]),e._v(" "),t("ul",[t("li",[e._v("The presentation of the rules for assignment compatibility($1.8.7, $Ⅲ.1.8.1.2.3) has been extensively revised to a more precise and clearer relation-based format.")]),e._v(" "),t("li",[e._v("The presentation of the verification rules for many IL instructions has been revised to be more precise and clearer by building upon the revisions to the presentation of assignment compatibility.")]),e._v(" "),t("li",[e._v("The presentation of delegate signature compatibility has been revised a long the same lines as assignment compatibility.")]),e._v(" "),t("li",[e._v("The verification rules for the IL newobj instruction have been extended to cover general delegate creation.")]),e._v(" "),t("li",[e._v("The dispatch rules for variance($Ⅱ.12.2) have been extended to define resolutions for the ambiguities that can arise.")]),e._v(" "),t("li",[e._v("Type forwarders have been added to support the relocation of types between libraries($Ⅱ.6.8)")])]),e._v(" "),t("p",[e._v("标准中添加、扩展或阐明了以下特性：")]),e._v(" "),t("ul",[t("li",[e._v("分配兼容性规则的表示（$1.8.7，$Ⅲ.1.8.1.2.3）已被广泛修改为更精确和更清晰的基于关系的格式。")]),e._v(" "),t("li",[e._v("许多 IL 指令的验证规则的表示已通过对分配兼容性表示的修订进行了修订，使其更加精确和清晰。")]),e._v(" "),t("li",[e._v("代表签名兼容性的表示已被修改为与分配兼容性相同的行。")]),e._v(" "),t("li",[e._v("IL newobj 指令的验证规则已扩展为涵盖一般委托创建。")]),e._v(" "),t("li",[e._v("差异调度规则（$Ⅱ.12.2）已扩展为定义可能出现的歧义的解决方案。")]),e._v(" "),t("li",[e._v("添加类型转发器，支持库之间类型的重定位($Ⅱ.6.8)")])]),e._v(" "),t("p",[e._v("The following changes of behavior have been made to Standard:")]),e._v(" "),t("ul",[t("li",[e._v("The semantics of variance has been redefined making it a core feature of the CLI. In the previous edition of the Standard varance could be ignored by languages not wishing to support it ($1.8); as exact type matches always took prevedence over matches-by-variance. In this edition the dispatch rules for interfaces $Ⅱ.12.2)allow a match-by-variance to take precedence over an exact match, so all language implementation targeting the CLI must be aware of the behavior even if it is not support in language($1.8)")])]),e._v(" "),t("p",[e._v("变异的语义已被重新定义，使其成为 CLI 的核心特性。 在标准的先前版本中，不希望支持它的语言可以忽略它（$1.8）； 因为精确类型匹配总是优先于按方差匹配。 在此版本中，接口 $Ⅱ.12.2) 的调度规则允许按变量匹配优先于精确匹配，因此所有针对 CLI 的语言实现都必须了解该行为，即使它在语言中不受支持（ $1.8）")]),e._v(" "),t("ul",[t("li",[e._v("Additional requirements on ilasm to metadata conversion. The left-to-right order of interfaces listed in a type header($Ⅱ.10.2) must now be preserved as a top-to-bottom order in the InterfaceImpltable($Ⅱ.22.23); and the top-to-bottom of method definitions($Ⅱ.10.2, $Ⅱ.15) must now be preserved as a top-to-bottom order in the MethodDef table($Ⅱ.22.26). Both these additional requirements are required to support the revised variance sematics.")])]),e._v(" "),t("p",[e._v("对 ilasm 到元数据转换的附加要求。 类型标头（$Ⅱ.10.2）中列出的接口从左到右的顺序现在必须在 InterfaceImpltable（$Ⅱ.22.23）中保留为从上到下的顺序； 并且方法定义的从上到下（$Ⅱ.10.2，$Ⅱ.15）现在必须作为从上到下的顺序保留在 MethodDef 表（$Ⅱ.22.26）中。 这两项额外要求都是支持修订后的方差语义所必需的。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("System.Math and System.Double have been modified to better confirm to IEEE (insert correct ref to IEEE standard here, and ref lib XML)")])]),e._v(" "),t("li",[t("p",[e._v("System.Math 和 System.Double 已被修改以更好地与 IEEE 确认（在此处插入正确的 IEEE 标准参考，并参考 lib XML）")])])]),e._v(" "),t("p",[e._v("The following types have been added to the Standard or have been significantly updated(* represents an update)")]),e._v(" "),t("p",[e._v("以下类型已添加到标准或已显着更新（* 代表更新）")]),e._v(" "),t("p",[e._v("略过表格")]),e._v(" "),t("p",[e._v("Technical Report 89(TR89), which was submitted during the third edition of the Ecma standard, will no longer be part of the submission. TR89 specified a collection of generic types, to help enhance inter-language interoperabiliby, under consideration for inclusion in a future version of the standard. That consideration has now occurred and TR89 has fulfilled its role. A selection of the types covered in TR89 has been introduced into this edition of the standard. An archive version of TR89 will continue to be available from Ecma.")]),e._v(" "),t("p",[e._v("在 Ecma 标准第三版期间提交的技术报告 89（TR89）将不再是提交的一部分。 TR89 指定了一组通用类型，以帮助增强语言间的互操作性，正在考虑将其包含在标准的未来版本中。 这种考虑现在已经发生，TR89 已经发挥了作用。 TR89 中涵盖的一系列类型已被引入此版本的标准中。 Ecma 将继续提供 TR89 的存档版本。")]),e._v(" "),t("p",[e._v("The following companies and organizations have participated in the development of this standard, and their contributions are gratefully acknowledged: Eiffel Software, Kahu Research, Microsoft Corporation, Novell Corporation, Twin Roots. For previous editions, the following companies and organizations are also acknowledged: Borland, Fujitsu Software Corporation, Hewlett-Packard, Intel Corporation, IBM Corporation, IT University of Copenhagen, Jagger Software Ltd., Monash University, Netscape, Phone.Com, Plum Hall, and Sun Microsystem.")]),e._v(" "),t("p",[e._v("以下公司和组织参与了本标准的制定，并感谢他们的贡献：Eiffel Software、Kahu Research、Microsoft Corporation、Novell Corporation、Twin Roots。 对于以前的版本，以下公司和组织也得到认可：Borland、富士通软件公司、惠普、英特尔公司、IBM 公司、哥本哈根 IT 大学、Jagger Software Ltd.、莫纳什大学、Netscape、Phone.Com、Plum Hall 和 Sun 微系统。")]),e._v(" "),t("h2",{attrs:{id:"_1-scope"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-scope"}},[e._v("#")]),e._v(" 1 Scope")]),e._v(" "),t("p",[e._v("The International Standard defines the Common Language Infrastructure(CLI) in whick applications written in multiple high-level languages can bue executed in different system environments without the need to rewrite those applications to take into consideration the unique characteristics of those environments. This International Stansard consists of the following parts:")]),e._v(" "),t("p",[e._v("国际标准定义了公共语言基础设施 (CLI)，其中以多种高级语言编写的应用程序可以在不同的系统环境中执行，而无需重写这些应用程序以考虑这些环境的独特特性。 本国际标准由以下部分组成：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Partition Ⅰ: Concepts and Architecture - Describes the overall architecture of the CLI, and provides the normative description of the Common Type System(CTS), the Virtual Execution System(VES), and the Common Language Specification(CLS). It also provides an informative description of the metadata.")])]),e._v(" "),t("li",[t("p",[e._v("第一部分：概念和架构 - 描述 CLI 的整体架构，并提供通用类型系统（CTS）、虚拟执行系统（VES）和通用语言规范（CLS）的规范性描述。 它还提供了元数据的信息描述。")])]),e._v(" "),t("li",[t("p",[e._v("Partition Ⅱ: Metadata Definition and Semantics - Provides the normative description of the metadata: its physical layout(as a file format), its logical content(as a set of tables and their relations ship), and its semantics( as seen from a hypothetical assembler, ilasm).")])]),e._v(" "),t("li",[t("p",[e._v("第二部分：元数据定义和语义——提供元数据的规范描述：它的物理布局（作为一种文件格式），它的逻辑内容（作为一组表及其关系），它的语义（从一个假设的角度来看） 汇编程序，伊斯兰教）。")])]),e._v(" "),t("li",[t("p",[e._v("Partition Ⅲ: CIL Instruction Set - Describes the Common Intermediate Language(CLI) instruction set.")])]),e._v(" "),t("li",[t("p",[e._v("Partition IV: Profiles and Libraries - Provides and overview of the CLI Libraries, and a specification of their factoring into Profiles and Libraries. A companion file, CLILibrary.xml, considered to be part of this Partition, but distributed in XML format, provides details of each class, value type, and interface in the CLI Libraties.")])]),e._v(" "),t("li",[t("p",[e._v("第 IV 部分：配置文件和库 - 提供和概述 CLI 库，以及将它们分解为配置文件和库的规范。 伴随文件 CLILibrary.xml 被认为是此分区的一部分，但以 XML 格式分发，提供 CLI 库中每个类、值类型和接口的详细信息。")])]),e._v(" "),t("li",[t("p",[e._v("Partition Ⅴ: Debug Interchange Format - Describes a standard way to interchange debugging information between CLI producers and consumers.")])]),e._v(" "),t("li",[t("p",[e._v("Partition Ⅵ: Annexes - Contains some sample programs written in CLI Assembly Language(ILAssm), information about a particular implementation of an assembler, a machine-readable descripton of the CIL instruction set which can be used to derive parts of the grammar used by this assembler as well as other tools that manipulate CIL, a set of guidelines used in the design of the libraries of Partition IV, and portability considerations.")])])]),e._v(" "),t("h2",{attrs:{id:"_2-conformance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-conformance"}},[e._v("#")]),e._v(" 2 Conformance")]),e._v(" "),t("p",[e._v("A system claiming conformance to this International Standard shall implement all the normative requirements of this standard, and shall specify the profile( see Patrion Ⅳ Library - Profiles) that it implements. Ths minimal implementations is the Kernel Profile. A conforming implementation can also include additional functionality provided that functionality does not prevent running code written to rely solely on the profile as specified in this standard. For example, a conforming implementation can provide additional classes, new methods on existing classes, or a new interface on a standardized class, but it shall not add methods or properties to interfaces specified in this standard.")]),e._v(" "),t("p",[e._v("A compiler that generates Common Intermediate Language(CIL, see Partition Ⅲ) and claims conformance to this International Standard shall produce output files in the format specified in this standard, and this CIL it generates shall be correct CIL as specified in this standard. Such a compiler can also chaim that it generates verifiable code, in which case, the CIL it generates shall be verifiable as specified in this standard.")]),e._v(" "),t("h2",{attrs:{id:"_4-conventions-约定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-conventions-约定"}},[e._v("#")]),e._v(" 4 Conventions 约定")]),e._v(" "),t("h3",{attrs:{id:"_4-1-orfanization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-orfanization"}},[e._v("#")]),e._v(" 4.1 Orfanization")]),e._v(" "),t("p",[e._v("The divisons of this International Standard are organized using a hierarchy. At the top level is the "),t("code",[e._v("Partition")]),e._v(". The next level is "),t("code",[e._v("clause")]),e._v(", followed by "),t("code",[e._v("subclause")]),e._v(". Divisions within a subclause are alse referred to as subclauses. Partitions are numbered using Roman numerals. All other divisions are numbered using Arabic digits with their plave in hierarchy indicated by nested numbers. For example, Partion Ⅱ, 14.4.3.2 refers to subclause 2 in subclause 3 in subclause 4 in clause 14 in Partition Ⅱ.")]),e._v(" "),t("p",[e._v("本国际标准的各部分使用层次结构进行组织。")]),e._v(" "),t("h2",{attrs:{id:"_5-terms-and-definitions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-terms-and-definitions"}},[e._v("#")]),e._v(" 5 Terms and definitions")]),e._v(" "),t("p",[e._v("For the purposes of this International Standard, the following definitions apply. Other terms are defines where the appear in "),t("code",[e._v("italic")]),e._v(" type.")]),e._v(" "),t("p",[e._v("为本国际标准的目的，下列定义适用。 其他术语定义了以“斜体”类型出现的位置。")]),e._v(" "),t("p",[t("strong",[e._v("ANSI character:")]),e._v(" A character from an implementation-defined 8-bit character set whose first 128 code points correspond exactly to those of ISO/IEC 10646.")]),e._v(" "),t("p",[t("strong",[e._v("ANSO string:")]),e._v(" A string of ANSI characters, of which the final character has the value all-bits-zero.")]),e._v(" "),t("p",[t("strong",[e._v("argument:")]),e._v(" The expression supplied for a parameter at the point of the call to a method.")]),e._v(" "),t("p",[t("strong",[e._v("assembly:")]),e._v(" A configured set of loadable code modules and other resources that together implement a unit of functionality.")]),e._v(" "),t("p",[t("strong",[e._v("attribute:")]),e._v(" A characteristic of a type and/or its menbers that contains descriptive information. While the most common attributes are predefined, and have a specific encoding in the metadata associated with then, userdefined attributes can also be added to the metadata.")]),e._v(" "),t("p",[t("strong",[e._v("behavior, implementation-specific:")]),e._v(" Unspecified behavior, for which each implementation is required to document the choice it makes.")]),e._v(" "),t("p",[t("strong",[e._v("behavior, unspecified:")]),e._v(" Behavior, for a well-formed program construct and correct data, that depends on the implementation. The implementation is not required to document which behavior occurs.")]),e._v(" "),t("p",[t("strong",[e._v("behavior, undefined:")]),e._v(" Behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes no requirements. Undefined behavior can also be expected in cases when this International Standard omits the description of any explicit definition of vehavior.")]),e._v(" "),t("p",[t("strong",[e._v("boxing:")]),e._v(" The conversion of a value having some value type, to a newly allocated instance of the reference type "),t("code",[e._v("System.Object")]),e._v(".")]),e._v(" "),t("p",[e._v("将具有某种值类型的值转换为引用类型“System.Object”的新分配实例。")]),e._v(" "),t("p",[t("strong",[e._v("Common Intermediate Language(CIL):")]),e._v(" The instruction set understood by the VES.")]),e._v(" "),t("p",[t("strong",[e._v("Common Language Infrastructure(CLI):")]),e._v(" A specification for the format of executable code, and the runtime environment that can execute the code.\n可执行代码格式的规范，以及可执行代码的运行时环境。")]),e._v(" "),t("p",[t("strong",[e._v("Common Type System(CTS):")]),e._v(" A unified type system that is shared by compilers, tools, and the CLI itself. It is the model that defines the rules the CLI follows when declaring, using and managing types. The CTS established a framework that enables cross-language integration, type safety, and high performance code execution.")]),e._v(" "),t("p",[t("strong",[e._v("delegate:")]),e._v(" A reference type such that an instance of it can encapsulate one or more methods in an invocation list. Given a delegate instance and an appropriate set of arguments, one can invoke all of the methods in a delegate's invocation list with that set of arguments.")]),e._v(" "),t("p",[t("strong",[e._v("event:")]),e._v(" A member that enables an object or class ro provide notifications.")]),e._v(" "),t("p",[t("strong",[e._v("Execution Engine:")]),e._v(" See Virtual Execution System.")]),e._v(" "),t("p",[t("strong",[e._v("field:")]),e._v(" A member that designates a typed memory location that stores some data in a program")]),e._v(" "),t("p",[t("strong",[e._v("garbage collection:")]),e._v(" The process by which memory for managed data is allocated and released.")]),e._v(" "),t("p",[t("strong",[e._v("generic argument:")]),e._v(" The actual type used to instantiate a particular generic type or generic method. For example in "),t("code",[e._v("List<string>, string")]),e._v(" is the generic argument corresponding to the generic parameter T in the generic type definition "),t("code",[e._v("List<T>")]),e._v(".")]),e._v(" "),t("p",[t("strong",[e._v("generic parameter:")]),e._v(" A parameter within the definition of a generic type or generic method that acts as a place holder for a generic argument. For example, in the generic type definition "),t("code",[e._v("List<T>")]),e._v(", T is a generic parameter.")]),e._v(" "),t("p",[t("strong",[e._v("generics:")]),e._v(" The feature that allows types and methods to be defined such that they are parameterized with one or more generic parameters.")]),e._v(" "),t("p",[t("strong",[e._v("library:")]),e._v(" A repository for a set of types, which are grouped into one or more assemblies. A library can also contain medifications to types defined in other libraries. For example, A library can include additional methods, interfaces, and exceptions for types defined in other libraries.")]),e._v(" "),t("p",[t("strong",[e._v("signature:")]),e._v(" The part of a contract that can be checked and automativally enforced. Signatures are formed by adding constraints to types and other signatures. A constraint is a limitation on the use of or allowed operations on a value or location.")]),e._v(" "),t("p",[e._v("**type,generic:**A type whose definition is parameterized by one or more other types; for example, "),t("code",[e._v("List<T>")]),e._v(" where T is a generic parameter. The CLI supports the creation and use of instances of generic types. For example, List"),t("int32",[e._v(" or List"),t("string",[e._v(".")])],1)],1),e._v(" "),t("p",[t("strong",[e._v("type,reference:")]),e._v(" A type such that an instance of it contains a reference to its data.")]),e._v(" "),t("p",[e._v("**type, value:**A type such that an instance of it directly contains all its data.")]),e._v(" "),t("p",[t("strong",[e._v("unboxing:")]),e._v(" The conversion of a value having type "),t("code",[e._v("System.Object")]),e._v(", whose run-time type is a value type, to a value type instance.")]),e._v(" "),t("p",[t("strong",[e._v("unmanaged code:")]),e._v(" Code that is not managed.")]),e._v(" "),t("p",[t("strong",[e._v("unmanaged data:")]),e._v(" Data that is not managed.")]),e._v(" "),t("p",[t("strong",[e._v("value:")]),e._v(" A simple bit pattern for something like an integer of a float. Each value has a type that describes both the storage that it occupies and the meanings of the bits in its representation, and also the operations that can be performed on that representation. Values are intended for representing the simple types and non-objects in preogramming languages.")]),e._v(" "),t("p",[t("strong",[e._v("verification:")]),e._v(" The checking of both CIL and its related metadata to ensure that the CIL code sequences do not permit any access to memory outside the program's logical address space. In conjunction with the calidation tests, verification ensures that the program cannot access memory or other resources to which it is not granted access.")]),e._v(" "),t("p",[t("strong",[e._v("Virtual Execution System(VES):")]),e._v(" This system implements and enforces the CTS model. The VES is reponsible for loading and running programs written for the CLI. It provides the services needed to execute managed code and data using the metadata to connect separately generated modules together at runtime. The VES is also know as the Execution Engine.")]),e._v(" "),t("h3",{attrs:{id:"_6-overview-of-the-common-language-infrastructure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-overview-of-the-common-language-infrastructure"}},[e._v("#")]),e._v(" 6 Overview of the Common Language Infrastructure")]),e._v(" "),t("p",[e._v("The Common Landuage Infrastructure(CLI) provides a specification for executable code and the execution environment(the Virtual Execution System) in which it runs. Executable code is presented to the VES as modules. A module is a signle file containing executable content in the format specified in Partition Ⅱ-Security.")]),e._v(" "),t("p",[e._v("The remainder of this clause and its subclauses contain only informative text")]),e._v(" "),t("p",[e._v("At the center of the CLI is a unified type system, the Common Type System that is shared by compilers, tools, and the CLI itself. It is the model that defines the rules the CLI follows when declaring, using and managing types. The CTS established a framework that enables cross-language integration, type safety, and high performance code execution. This clause describes the architechure of the CLI by describing the CTS.")]),e._v(" "),t("p",[t("strong",[e._v("The Common Type System(CTS)")]),e._v("--The CTS provides a rich type system that supports the types and operations found in many programming languages. The CTS is intended to support the complete implementation of a wide range of programming languages. See $8")]),e._v(" "),t("p",[t("strong",[e._v("Metadata")]),e._v("--The CLI uses metadata to describe and reference the types defined by the CTS. Metadata is stored(that is, persisted) in a way that is independent of any particular programming language. Thus metadata provides a common interchange mechanism for use between tools (such as compilers and debuggers) that manipulate programs, as well as between these tools and the VES. See $9.")]),e._v(" "),t("p",[t("strong",[e._v("The Common Language Specification(CLS)")]),e._v("--The CLS is and agreement between language designers and framework(that is, class library) designers. It specifies a subset of the CTS and a set of usage conventions. Languages provide their users the greatest ability to access frameworks by implementing at least those parts of the CTS that are part of the CLS. Similarly, raame works will be most widely used if their publicly exportedaspect(e.g., classed, interfaces, methods, and fields) use only types that are part of the CLS and that adhere to the CLS conventions. See $10.")]),e._v(" "),t("p",[t("strong",[e._v("The Virtual Execution System(VES)")]),e._v("-- The Ves implements and enforces the CTS model. The VES is responsible for loading and running programs written for the CLI. It provides the services needed to execute managed code and data, using the metadata to connect separately generated modules together at runtime(late binding). See $1.2")]),e._v(" "),t("p",[e._v("Together, these aspects of the CLI from a unifying infrastructure for designing, developing, deploying, and executing distributed components and applications. The appropriate subset of the CTS is available from each programming language that targets the CLI. Language-based tools communicate with each other and with the VES using metadata to define and reference the types used to construct the application. The VES uses the metadata to create instance of the types as needed and to provide data type information to other parts of the infrastructure(such ad remoting services, assembly downloading, and security).")]),e._v(" "),t("h3",{attrs:{id:"_6-1-relationship-to-type-safety"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-relationship-to-type-safety"}},[e._v("#")]),e._v(" 6.1 Relationship to type safety")]),e._v(" "),t("p",[e._v("Type safety is usually discussed in terms of whar id does(e.g., guaranteeing encapsulation between different objects) or in terms of what it prevents(e.g, memory corruption by writing where one shouldn't). However, from the point of view of thw CTS, type safety guarantees that:")]),e._v(" "),t("p",[t("strong",[e._v("References are what they say they are")]),e._v(" - Every reference is typed, the object or value referenced alse has a type, and these types are assignement compatible(see $8.7).")]),e._v(" "),t("p",[t("strong",[e._v("Indentities are who they say they are")]),e._v(" - There is no way to corrupt or spoof an object, and by implication, a user or security domain. Access to an object is through accessible functions and fields. An object can still be designed in such a way that security is compromised. However, a local analysis of the class, its methods, and the things it uses, as openosed to a global analysis of all uses of a class, is sufficient to assess the vulnerabilities.")]),e._v(" "),t("h3",{attrs:{id:"_1-4-english-description"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-english-description"}},[e._v("#")]),e._v(" 1.4 English description")]),e._v(" "),t("p",[e._v("The English description describes any details about the instructions that are not immediately apparent once the format and stack transition have been described.")]),e._v(" "),t("p",[e._v("在描述了格式和堆栈转换之后，英文描述描述了这些指令不能使用格式和堆栈表示的其它信息")]),e._v(" "),t("h1",{attrs:{id:"partion-iii-cli"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#partion-iii-cli"}},[e._v("#")]),e._v(" Partion Ⅲ CLI")]),e._v(" "),t("p",[e._v("Common Language Infrastucture(CLI)\n通用语言架构")]),e._v(" "),t("p",[e._v("Partition Ⅲ\nCIL Instruction Set\n通用语言架构指令系统")]),e._v(" "),t("h2",{attrs:{id:"_1-introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction"}},[e._v("#")]),e._v(" 1. Introduction")]),e._v(" "),t("p",[e._v("介绍")]),e._v(" "),t("ul",[t("li",[e._v("A list of exceptions that might be thrown by instruction.")]),e._v(" "),t("li",[e._v("A section describing the verifiability condition associated with the instruction.")]),e._v(" "),t("li",[e._v("一个描述指令相关可验证性的部分")])]),e._v(" "),t("h3",{attrs:{id:"_1-1-data-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-data-types"}},[e._v("#")]),e._v(" 1.1 Data Types")]),e._v(" "),t("p",[e._v("数据类型")]),e._v(" "),t("h4",{attrs:{id:"_1-1-1-numeric-data-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-numeric-data-types"}},[e._v("#")]),e._v(" 1.1.1 Numeric data types")]),e._v(" "),t("ul",[t("li",[e._v("The CLI only operates on the numeric types int32(4-byte signed integers), int64(8-byte signed integers), native int(native-size integers), and F(native-size floating-point numbers). However, the CIL instruction set allows additional data types to be implemented:")]),e._v(" "),t("li",[t("strong",[e._v("Short integers")]),e._v(": The evaluation stack only holds 4- or 8-byte integers, but other locations")])]),e._v(" "),t("h2",{attrs:{id:"_1-5-operand-type-table"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-operand-type-table"}},[e._v("#")]),e._v(" 1.5 Operand type table")]),e._v(" "),t("p",[e._v("操作数类型表")]),e._v(" "),t("p",[e._v("Many CIL operations take numeric operands on the stack. These operations fail into several categories, depending on how they deal with the types of the operands. The following tables summarize the valid kinds of operand types and the type of the result. Notive that the type referred to here is the type as tracked by the CLI rather than the more detailed types used by tools such as CIL verfication. The types tracked by the CLI are: int32, int64, native int, F, O, and &.")]),e._v(" "),t("p",[e._v("Table 2 show the result type for A op B--where op is add, div, mul rem, or sub--for each possible combination of operand types. Boxed holding simply a result type, apply to all five instructions. Boxes marked x indicate an invalid CIL instruction. Shaded boxes indicate a CIL instruction that is not verifiable. Boxes with a list of instructions are valid only for those instructions.")]),e._v(" "),t("h2",{attrs:{id:"_2-prefixes-to-instructions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-prefixes-to-instructions"}},[e._v("#")]),e._v(" 2 Prefixes to instructions")]),e._v(" "),t("h3",{attrs:{id:"_2-3-readonly-prefix-following-instruction-returns-a-controlled-mutability-managed-pointer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-readonly-prefix-following-instruction-returns-a-controlled-mutability-managed-pointer"}},[e._v("#")]),e._v(" 2.3 readonly. (prefix) - following instruction returns a controlled-mutability managed pointer")]),e._v(" "),t("h2",{attrs:{id:"_3-base-instructions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-base-instructions"}},[e._v("#")]),e._v(" 3 Base instructions")]),e._v(" "),t("p",[e._v('基础指令\nThese instructions from a "Turing Complete" set of basic operations. They are independent of object model that might be employed. Operations that are specifically related to the CTS\'s object model are contained in the Object Model Instructions section.')]),e._v(" "),t("p",[e._v("这些指令集来自一组“图灵完备”的基本操作。他们独立于可能使用的对象模型。与CTS的对象模型相关的操作，包含在对象模型说明部分中。")]),e._v(" "),t("h3",{attrs:{id:"_3-1-add-add-numeriv-values"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-add-add-numeriv-values"}},[e._v("#")]),e._v(" 3.1 add - add numeriv values")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("58")]),e._v(" "),t("td",[e._v("add")]),e._v(" "),t("td",[e._v("Add two values, returning a new value.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition")]),e._v(":\n..., value1, value2 -> ..., result\n"),t("strong",[e._v("Desctiption:")]),e._v("\nThe add instruction adds value2 to value1 and pushes the result on the stack. Overflow is not detected for integral operations(but see add.ovf); floating-point overflow returns +inf or -inf.")]),e._v(" "),t("p",[e._v("add 指令将value2加到value1上，并且推送结果（result）到栈上。完整运算没有检测溢出（但请参间add.ovf）；浮点运算溢出返回 +inf或-inf。")]),e._v(" "),t("p",[e._v("The acceptable operand types and their corresponging result data type are encapsulated in Table 2:Binary Numeric Operations.")]),e._v(" "),t("p",[e._v("可接受的操作数类型及其对应结果数据类型封装在表2:二进制数值运算。")]),e._v(" "),t("p",[t("strong",[e._v("Exceptions：")]),e._v("\nNone")]),e._v(" "),t("p",[e._v("Correctness And Verifiability:\nSee Table 2:Binary Numeric Operations.")]),e._v(" "),t("p",[e._v("正确性和可验证性\n见表2:二进制数值运算。")]),e._v(" "),t("h3",{attrs:{id:"_3-5-beq-length-branch-on-equal"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-beq-length-branch-on-equal"}},[e._v("#")]),e._v(" 3.5 beq.<length> - branch on equal")]),e._v(" "),t("p",[e._v("相等的分支")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("38<int32>")]),e._v(" "),t("td",[e._v("beq target")]),e._v(" "),t("td",[e._v("Branch to target if equal.")])]),e._v(" "),t("tr",[t("td",[e._v("2B<int8>")]),e._v(" "),t("td",[e._v("beq.s target")]),e._v(" "),t("td",[e._v("Branch to target if equal, short form.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., -> ...")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The beq instruction transfers control to target if value1 is equal to value2. The effect is identical to performing a ceq instruction followed by a brtrue target. target is representedas a signed offset(4 bytes for beq, 1 byte for beq.s) from the beginning of the instruction following the current instruction.")]),e._v(" "),t("p",[e._v("如果 value1 等于 value2，则 beq 指令将控制转移到目标。 效果与执行 ceq 指令后跟 brtrue 目标相同。 target 表示为从当前指令之后的指令开头开始的有符号偏移量（beq 为 4 个字节，beq.s 为 1 个字节）。")]),e._v(" "),t("h3",{attrs:{id:"_3-15-br-length-unconditional-branch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-15-br-length-unconditional-branch"}},[e._v("#")]),e._v(" 3.15 br.<length> - unconditional branch")]),e._v(" "),t("p",[e._v("无条件分支")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("38<int32>")]),e._v(" "),t("td",[e._v("br target")]),e._v(" "),t("td",[e._v("Branch to target.")])]),e._v(" "),t("tr",[t("td",[e._v("2B<int8>")]),e._v(" "),t("td",[e._v("br.s target")]),e._v(" "),t("td",[e._v("Branch to target, short form.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., -> ...")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The br instruction unconditionally transfers control to target. target is represented as a signed offset(4 bytes for br, 1 byte for br.s) from the beginning of the instruction following the current instruction.")]),e._v(" "),t("p",[e._v("br 指令无条件地将控制转移到目标。 target 表示为从当前指令之后的指令开头开始的有符号偏移量（br 为 4 字节，br.s 为 1 字节）。")]),e._v(" "),t("p",[e._v("If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.")]),e._v(" "),t("p",[e._v("如果目标指令有一个或多个前缀代码，则控制只能转移到这些前缀中的第一个。")]),e._v(" "),t("p",[e._v("Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.(Such transfers are severely restricted and shall use the leave instruction instead; see Partition I for details).")]),e._v(" "),t("p",[e._v("此指令无法执行进出 try、catch、filter 和 finally 块的控制转移。（此类转移受到严格限制，应使用 leave 指令代替；详见第一部分）。")]),e._v(" "),t("p",[e._v("[Rationale: While a leave instruction can be used instead of a br instruction when the evaluation stack is empty, doing so might increase the resource required to compile from CIL to native code and/or lead to inferior native code. Therefore CIL generators should use a br instruction in perference to a leave instruction when both are valid. end rationale]")]),e._v(" "),t("p",[e._v("【理由：虽然当评估堆栈为空时可以使用离开指令而不是 br 指令，但这样做可能会增加从 CIL 编译为本机代码所需的资源和（或）导致劣质本机代码。 因此，当两者都有效时，CIL 生成器应该使用 br 指令而不是 leave 指令。 结束理由】")]),e._v(" "),t("h3",{attrs:{id:"_3-17-brfalse-length-branch-on-false-null-or-zero"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-17-brfalse-length-branch-on-false-null-or-zero"}},[e._v("#")]),e._v(" 3.17 brfalse.<length> - branch on false, null, or zero")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("39<int32>")]),e._v(" "),t("td",[e._v("brfalse target")]),e._v(" "),t("td",[e._v("Branch to target if value is zero(false).")])]),e._v(" "),t("tr",[t("td",[e._v("2C"),t("int8")],1),e._v(" "),t("td",[e._v("brfalse.s target")]),e._v(" "),t("td",[e._v("Branch target if value is zero(false), short form")])]),e._v(" "),t("tr",[t("td",[e._v("39<int32>")]),e._v(" "),t("td",[e._v("brnull target")]),e._v(" "),t("td",[e._v("Branch to target if value is null(alias for brfalse)")])]),e._v(" "),t("tr",[t("td",[e._v("2C<int8>")]),e._v(" "),t("td",[e._v("brnull.s target")]),e._v(" "),t("td",[e._v("Branch to  target if value is null(alias for brfalse.s), short form.")])]),e._v(" "),t("tr",[t("td",[e._v("39<int32>")]),e._v(" "),t("td",[e._v("brzero target")]),e._v(" "),t("td",[e._v("Branch to target if value is zero(alias for brfalse).")])]),e._v(" "),t("tr",[t("td",[e._v("2C\\Cint8>")]),e._v(" "),t("td",[e._v("brzero.s target")]),e._v(" "),t("td",[e._v("Branch to target if value is zero(alias for brfalse.s), short form.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., value -> ...")]),e._v(" "),t("p",[t("strong",[e._v("Desctiption:")])]),e._v(" "),t("p",[e._v("The brfalse instruction transfers control to target if value (of type int32, int64, object reference, managed pointer, unmanaged pointer or native int) is zero(false). If value is non-zero(true), execution continues at the next instruction.")]),e._v(" "),t("p",[e._v("如果值（类型为 int32、int64、对象引用、托管指针、非托管指针或本机 int）为0（假），则 brfalse 指令将控制转移到目标。 如果值非0（真），则在下一条指令处继续执行。")]),e._v(" "),t("p",[e._v("Target is represented as a signed offset(4 bytes for brfalse, 1byte for brfalse.s) from the beginning of the instruction following the current instruction.")]),e._v(" "),t("h3",{attrs:{id:"_3-22-cgt-compare-greater-than"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-22-cgt-compare-greater-than"}},[e._v("#")]),e._v(" 3.22 cgt - compare greater than")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("FE 02")]),e._v(" "),t("td",[e._v("Cgt")]),e._v(" "),t("td",[e._v("Push 1 (of type int32) if value1 > value2, else push 0.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., value1, value2 -> ..., result")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The cgt instruction compares value1 and value2. If value1 is strictly greater than value2, then 1(of type int32) is pushed on the stack. Otherwise, 0(of type int32) is pushed on the stack.")]),e._v(" "),t("p",[e._v("For floating-point numbers, cgt returns 0 if the numbers are unordered(that is, if one or both of the arguments are NaN).")]),e._v(" "),t("p",[e._v("对于浮点数，如果数字是无序的（即，如果一个或两个参数都是 NaN），则 cgt 返回 0。")]),e._v(" "),t("p",[e._v("As with IEC 60559:1989, infinite values are ordered with respect to normal numbers(e.g., +infinity>5.0>-infinity).")]),e._v(" "),t("h3",{attrs:{id:"_3-39-ldarga-length-load-an-argument-address"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-39-ldarga-length-load-an-argument-address"}},[e._v("#")]),e._v(" 3.39 ldarga.<length> - load an argument address")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("FF 0A<unsigned int16>")]),e._v(" "),t("td",[e._v("ldarga argNum")]),e._v(" "),t("td",[e._v("Fetch the address of argument argNum.")])]),e._v(" "),t("tr",[t("td",[e._v("OF<unsigned int8>")]),e._v(" "),t("td",[e._v("ldarga.s argNum")]),e._v(" "),t("td",[e._v("Fetch the address og argument argNum, short form.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., -> ..., address of argument number argNum")]),e._v(" "),t("p",[t("strong",[e._v("Desctiption:")])]),e._v(" "),t("p",[e._v("The ldarga instruction ftches the address(of type &, i.e., managed pointer) of the argNum'th argument, where arguments are numbered 0 onwards. The address will always be aligned to a natural boundary on the target machine (cf. cpblk an init blk). The short form (ldargs.s) should be used for argument numbers 0-255. The result is managed pointer (type &).")]),e._v(" "),t("p",[e._v("ldarga 指令获取 argNum'th 参数的地址（类型为 &，即托管指针），其中参数从 0 开始编号。 该地址将始终与目标机器上的自然边界对齐（参见 cpblk 和 init blk）。 短格式 (ldargs.s) 应用于参数编号 0-255。 结果是托管指针（类型 &）。")]),e._v(" "),t("p",[e._v("For procedures that take a variable-length argument list, the ldarga instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.")]),e._v(" "),t("p",[e._v("对于采用可变长度参数列表的过程，ldarga 指令只能用于初始固定参数，不能用于签名可变部分中的参数。")]),e._v(" "),t("h3",{attrs:{id:"_3-4-1-ldftn-load-method-pointer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1-ldftn-load-method-pointer"}},[e._v("#")]),e._v(" 3.4.1 ldftn - load method pointer")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("FE 06<T>")]),e._v(" "),t("td",[e._v("ldftn method")]),e._v(" "),t("td",[e._v("Push a pointer to a method reference by method, on the stack.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("... -> ..., ftn")]),e._v(" "),t("p",[t("strong",[e._v("Desctiption:")])]),e._v(" "),t("p",[e._v("The ldftn instruction pushes a method pointer to the native code implementing the method described by method(a metadata token, either a methoddef or methodref), or to some other implementation-specific description of method (see Note) onto the stack). The value pushed can be called using the calli instruction if it references a managed method (or a stub that transitions from managed to unmanaged code). It may alse be used to construct a delegate, stored in a variable, etc.")]),e._v(" "),t("p",[e._v("ldftn 指令将方法指针推送到实现由方法描述的方法的本机代码（元数据标记，methoddef 或 methodref），或将方法的某些其他特定于实现的描述（见注）推送到堆栈上）。 如果推送的值引用托管方法（或从托管代码转换到非托管代码的存根），则可以使用 calli 指令调用推送的值。 它还可以用于构造委托、存储在变量中等。")]),e._v(" "),t("p",[e._v("The CLI resolves the method pointer according to the rules specified in 1.12.4.1.3(Computed destinations), except that the destination is computed with respect to the class specified by method.")]),e._v(" "),t("p",[e._v("CLI 根据 1.12.4.1.3（计算的目标）中指定的规则解析方法指针，但目标是相对于方法指定的类计算的。")]),e._v(" "),t("p",[e._v("The value returned points to native code (see Note) using the calling convention specified by method. Thus a method pointer can be passed to unmanaged native code(e.g., as a callback routine). Note that the address computed by this instruction can be to a thunk produced specially for this purpose(for excmple, to re-enter the CIL interpreter when a native version of the method isn't available).")]),e._v(" "),t("p",[e._v("返回的值使用方法指定的调用约定指向本机代码（见注）。 因此，可以将方法指针传递给非托管本机代码（例如，作为回调例程）。 请注意，此指令计算的地址可以是专门为此目的生成的 thunk（例如，当方法的本机版本不可用时重新进入 CIL 解释器）。")]),e._v(" "),t("h3",{attrs:{id:"_3-42-ldind-type-load-value-indirect-onto-the-stack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-42-ldind-type-load-value-indirect-onto-the-stack"}},[e._v("#")]),e._v(" 3.42 ldind.<type> - load value indirect onto the stack")]),e._v(" "),t("p",[e._v("将值间接加载到堆栈上")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("46")]),e._v(" "),t("td",[e._v("ldind.i1")]),e._v(" "),t("td",[e._v("Indrect load value of type int8 as int32 on the stack.")])]),e._v(" "),t("tr",[t("td",[e._v("48")]),e._v(" "),t("td",[e._v("ldind.i2")]),e._v(" "),t("td",[e._v("Indirect load value of type int16 as int32 on the stack.")])]),e._v(" "),t("tr",[t("td",[e._v("4A")]),e._v(" "),t("td",[e._v("ldind.i4")]),e._v(" "),t("td",[e._v("Indirect load value of type int32 as int32 on the stack.")])]),e._v(" "),t("tr",[t("td",[e._v("4C")]),e._v(" "),t("td",[e._v("ldind.i8")]),e._v(" "),t("td",[e._v("Indirect load value of type int64 as int64 on the stack.")])]),e._v(" "),t("tr",[t("td",[e._v("47")]),e._v(" "),t("td",[e._v("ldind.u1")]),e._v(" "),t("td",[e._v("Indirect load value of type unsigned int8 as int32 on the stack.")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td")])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., addr -> ..., value")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The ldind.<type> instruction indirectly loads a value from address addr (an unmanaged pointer, native int, or managed pointer, &) onto the stack. The source value is indicated by the instruction suffix. The ldind.ref instruction is a shortcut for a ldobj instruction that specifies the type pointed at by addr, all of the other ldind instructions are shortcuts for ldobj instruction that specifies the corresponding built-in value class.")]),e._v(" "),t("p",[e._v("ldind.<type> 指令将地址 addr（非托管指针、本机 int 或托管指针 &）中的值间接加载到堆栈上。 源值由指令后缀表示。 ldind.ref 指令是指定 addr 指向的类型的 ldobj 指令的快捷方式，所有其他 ldind 指令都是指定相应内置值类的 ldobj 指令的快捷方式。")]),e._v(" "),t("p",[e._v("If required, values are converted to the representation of the intermediate type (1.8.7) of the <type> in the instruction when loaded onto the stack.")]),e._v(" "),t("h3",{attrs:{id:"_3-48-mul-multiply-values"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-48-mul-multiply-values"}},[e._v("#")]),e._v(" 3.48 mul - multiply values")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("5A")]),e._v(" "),t("td",[e._v("mul")]),e._v(" "),t("td",[e._v("Multiply Values.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., value1, value2 -> ..., result")]),e._v(" "),t("p",[t("strong",[e._v("Desctiption:")])]),e._v(" "),t("p",[e._v("The mul instruction multiplies value1 by value2 and pushes the result on the stack. Integral operations silently truncate the upper bits on overflow(see mul.ovf).")]),e._v(" "),t("p",[e._v("For floating-point types, 0 x infinity = NaN.")]),e._v(" "),t("p",[e._v("The acceptable operand types and their corresponding result data types are encapsulated in Table 2: Binary Numeric Operations.")]),e._v(" "),t("h3",{attrs:{id:"_3-50-neg-negate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-50-neg-negate"}},[e._v("#")]),e._v(" 3.50 neg - negate")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("65")]),e._v(" "),t("td",[e._v("Neg")]),e._v(" "),t("td",[e._v("Negate value.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., value -> ..., result")]),e._v(" "),t("p",[t("strong",[e._v("Desctiption:")])]),e._v(" "),t("p",[e._v("The neg instruction negates value and pushes the result on top of the stack. The return type is the same as the operand type.")]),e._v(" "),t("p",[e._v("neg 指令取反值并将结果压入栈顶。 返回类型与操作数类型相同。")]),e._v(" "),t("p",[e._v("Negation of integral values is standard twos-complement negation. In particular, negating the most negative number(which does not have a positive counterpart) yields the most negative number. To detect this overflow use the sub.ovf instruction instead(i.e., subtract from 0).")]),e._v(" "),t("p",[e._v("整数值的否定是标准的二进制补码否定。 特别是，否定最负数（没有正数对应物）会产生最负数。 要检测此溢出，请改用 sub.ovf 指令（即从 0 中减去）。")]),e._v(" "),t("p",[e._v("Negating a floating-point number cannot overflow; negating NaN returns NaN.")]),e._v(" "),t("p",[e._v("对浮点数求反不能溢出； 否定 NaN 返回 NaN。")]),e._v(" "),t("p",[e._v("The acceptable operand types and their corresponding result data types are encapsulated in table3: Unary Numeric Operations.")]),e._v(" "),t("p",[e._v("可接受的操作数类型及其对应的结果数据类型封装在表3：一元数值运算中。")]),e._v(" "),t("p",[t("strong",[e._v("Exceptions:")])]),e._v(" "),t("p",[e._v("None.")]),e._v(" "),t("p",[t("strong",[e._v("Correctness and Verifiability:")])]),e._v(" "),t("p",[e._v("See Table 3: Unary Numeric Operations.")]),e._v(" "),t("h3",{attrs:{id:"_3-52-not-bitwise-complement"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-52-not-bitwise-complement"}},[e._v("#")]),e._v(" 3.52 not - bitwise complement")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("66")]),e._v(" "),t("td",[e._v("Not")]),e._v(" "),t("td",[e._v("Bitwise complement.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., value -> ..., result")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The not instruction computes the bitwise complement of the integer value on top of the stack and leaves the result on top of the stack. The return type is the same as the operand type.")]),e._v(" "),t("p",[e._v("not 指令计算栈顶部整数值的按位取反，并将结果留在堆栈顶部。 返回类型与操作数类型相同。")]),e._v(" "),t("h3",{attrs:{id:"_3-59-shr-shift-integer-right"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-59-shr-shift-integer-right"}},[e._v("#")]),e._v(" 3.59 shr - shift integer right")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("63")]),e._v(" "),t("td",[e._v("Shr")]),e._v(" "),t("td",[e._v("Shift an integer right(shift in sign), return an integer.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., value, shiftAmount -> ..., result")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The shr instruction shifts value(int32, int64 or native int) right by the number of bits specified by "),t("em",[e._v("shiftAmount")]),e._v(". "),t("em",[e._v("shiftAmount")]),e._v(" is of type int32 or native int. The return value is unspecified if "),t("em",[e._v("shiftAmount")]),e._v(" is greater than or equal to the width of value. shr replicates the high order bit on each shift, preserving the sign of the original value in result. See Table 6: Shift Operations for details of which operand types are allowed, and their corresponding result type.")]),e._v(" "),t("p",[e._v("shr 指令将值（int32、int64 或 native int）右移 "),t("em",[e._v("shiftAmount")]),e._v(" 指定的位数。 "),t("em",[e._v("shiftAmount")]),e._v(" 的类型为 int32 或原生 int。 如果 "),t("em",[e._v("shiftAmount")]),e._v(" 大于或等于 value 的宽度，则返回值未指定。 shr 在每次移位时复制高位，在结果中保留原始值的符号。 有关允许的操作数类型及其相应结果类型的详细信息，请参见"),t("u",[e._v("表 6：移位操作")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"_3-67-xor-bitwise-xor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-67-xor-bitwise-xor"}},[e._v("#")]),e._v(" 3.67 xor - bitwise XOR")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("61")]),e._v(" "),t("td",[e._v("xor")]),e._v(" "),t("td",[e._v("Bitwise XOR of integer values, returns an integer.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., value1, value2 -> ..., result")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The xor instruction computes the bitwise XOR of value1 and value2 and leaves the result on the stack.")]),e._v(" "),t("p",[e._v("xor 指令计算 value1 和 value2 的按位异或，并将结果留在堆栈中。")]),e._v(" "),t("p",[e._v("The acceptable operand types and their corresponding result data type is encapsulated in Table 5: Integer Operations.")]),e._v(" "),t("p",[t("strong",[e._v("Exceptions:")])]),e._v(" "),t("p",[e._v("None.")]),e._v(" "),t("p",[t("strong",[e._v("Correctness and Verifiability:")])]),e._v(" "),t("p",[e._v("see Table 5: Integer Operations.")]),e._v(" "),t("h2",{attrs:{id:"_4-object-model-instructions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-object-model-instructions"}},[e._v("#")]),e._v(" 4 Object model instructions")]),e._v(" "),t("h3",{attrs:{id:"_4-1-box-convert-a-boxable-value-to-its-boxed-form"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-box-convert-a-boxable-value-to-its-boxed-form"}},[e._v("#")]),e._v(" 4.1 box - convert a boxable value to its boxed form")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assemble Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("8C<T>")]),e._v(" "),t("td",[e._v("box typeTok")]),e._v(" "),t("td",[e._v("Convert a boxable value to its boxed form.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., val -> ..., obj")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("If typeTok is a value type, the box instruction converts val to its boxed form. When typeTok is a non-nullable type, this is done by creating a new object and copying the data from val into the newly allocated object. If it is a nullable type, this is done by inspecting val's HasValue property; if it is false, a null reference is pushed onto the stack; otherwise, the result of boxing val's Value property is pushed onto the stack.")]),e._v(" "),t("p",[e._v("如果typeTok是值类型，则Box指令将Val转换为装箱格式。 当typeTok是非可空的类型时，这是通过创建新对象并将数据从val复制到新分配的对象来完成的。 如果它是可空的类型，这是通过检查Val的HasValue属性来完成的; 如果是空的，则将空引用推入堆栈; 否则，拳击val值属性的结果被推到堆栈上。")]),e._v(" "),t("p",[e._v("If typeTok is reference type. the box instruction does returns val unchanged as obj.")]),e._v(" "),t("p",[e._v("如果typetok是引用类型。 box指令不改变Val并返回obj。")]),e._v(" "),t("p",[e._v('If typeTok is a generic parameter, the behavior of box instruction depends on the actual type at runtime. If this type is a value type it is boxed as above, if it is a reference type then val is not changed. However the type tracked by verifications is always "boxed" typeTok for generic parameters, regardless of whether the actural type at runtime is a value or reference type.')]),e._v(" "),t("p",[e._v("typeTok is a metadata token( a typedef, typeref, or typespec) indicating the type of val. typeTok can represent a value type, a reference type, or a generic parameter.")]),e._v(" "),t("p",[t("strong",[e._v("Exceptions:")])]),e._v(" "),t("p",[e._v("System.OutOfMemoryException is thrown if there is insufficient memory to satisfy the request.")]),e._v(" "),t("p",[e._v("如果内存不足以满足请求，则抛出异常 System.outofMemoryException")]),e._v(" "),t("p",[e._v("System.TypeLoadException is thrown if typeTok cannot be found. (This is typically detected when CIL is converted to native code rather than at runtime.)")]),e._v(" "),t("p",[e._v("如果找不到typeTok，则抛出system.typeloadexception。 （当CIL转换为本机代码而不是在运行时时，通常检测到。）")]),e._v(" "),t("h3",{attrs:{id:"_4-2-callvirt-call-a-method-associated-at-runtime-with-an-object"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-callvirt-call-a-method-associated-at-runtime-with-an-object"}},[e._v("#")]),e._v(" 4.2 callvirt - call a method associated, at runtime, with an object")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assemble Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("6F<T>")]),e._v(" "),t("td",[e._v("callvirt method")]),e._v(" "),t("td",[e._v("Call a method associated with an object.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v(".., obj, arg1, ... argN -> ..., returnVal (not always returned)")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The "),t("strong",[e._v("callvirt")]),e._v(" instruction calls a late-bound method on an object. That is, the method is chosen based on the exact type of obj rather than the compile-time class visible in the method metadata token. "),t("strong",[e._v("callvirt")]),e._v(" can be used to call both virtual and instance methods. See Partition 1 for a detailed description of the CIL calling sequence. The "),t("strong",[e._v("callvirt")]),e._v(" instruction can be immediately preceded by a "),t("strong",[e._v("tail")]),e._v(". prefix to specify that the current stack frame should be released before transferring control. If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.")]),e._v(" "),t("p",[t("strong",[e._v("CallVirt "),t("strong",[e._v("指令调用对象上的延迟方法。 也就是说，基于对OBJ的确切类型而不是在方法元数据token中可见的编译时类来选择该方法。 "),t("strong",[e._v("CallVirt")]),e._v("可用于调用虚拟和实例方法。 有关CIL调用序列的详细描述，请参阅分区1。 "),t("strong",[e._v("CallVirt")]),e._v("指令可以在之前的")]),e._v("tail")]),e._v("后立刻被执行。指定在传输控制之前应释放当前堆栈帧的前缀。 如果调用将控制到比原始方法更高的信任方法，则不会释放堆栈帧。")]),e._v(" "),t("p",[e._v('[A callee of "higher trust" is defined as one whose permission grant-set is a strict superset of the grant-set of the caller]')]),e._v(" "),t("p",[e._v("【“更高信任”的调用被定义为权限集是调用者权限集的严格超集】")]),e._v(" "),t("p",[e._v("method is metadata token (a methoddef, methodref or methodspec see Partion 2) that provides the name, class and signature of the method to call. In more detail, "),t("strong",[e._v("callvirt")]),e._v(" can be thought of as follows. Associated with obj is the class of which it is an instance. The CLI resolves the method to be called according to the rules specified in 1.12.4.1.3(Computed destinations).")]),e._v(" "),t("p",[t("strong",[e._v("callvirt")]),e._v(" pops the object and the arguments off the evaluation stack before calling the method. If the method has a return value, it is pushed on the stack upon method completion. On the callee side, the obj parameter is accessed as argument 0, arg1 as argument 1, and so on.")]),e._v(" "),t("p",[t("strong",[e._v("CallVirt")]),e._v("在调用方法之前弹出对象和evaluation堆栈的参数。 如果该方法具有返回值，则在方法完成时按下堆栈上。 在被调用者侧，obj参数作为第0个参数，arg1作为第1个参数访问，等等。")]),e._v(" "),t("h3",{attrs:{id:"_4-6-isinst-test-if-an-object-is-an-instance-of-a-class-or-interface"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-isinst-test-if-an-object-is-an-instance-of-a-class-or-interface"}},[e._v("#")]),e._v(" 4.6 isinst - test if an object is an instance of a class or interface")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assemble Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("75<T>")]),e._v(" "),t("td",[e._v("isinst typeTok")]),e._v(" "),t("td",[e._v("Test if obj is an instance of typeTok, returning null or an instance of that class or interface.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., obj -> ..., result")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v('typeTok is a metadata token (a typeref, typedef or typespec), indicating the desired class. If typeTok is a non-nullable value type or generic parameter type it is in interpreted as "boxed" typeTok. If typeTok is a nullable type, Nullable<T>, it is interpreted as "boxed" T.')]),e._v(" "),t("p",[e._v("typeTok 是元数据标记（typeref、typedef 或 typespec），指示所需的类。 如果 typeTok 是不可为空的值类型或泛型参数类型，则它被解释为“装箱”的 typeTok。 如果 typeTok 是可为空的类型 Nullable<T>，则将其解释为“装箱”T。")]),e._v(" "),t("p",[e._v("The isinst instruction tests whether obj (type O) is an instance of the type typeTok.")]),e._v(" "),t("p",[e._v("isinst 指令测试 obj（类型 O）是否是 typeTok 类型的实例。")]),e._v(" "),t("p",[e._v("If the actual type (not the verifier tracked type) of obj is verifier-assignable-to the type typeTok then isinst succeeds and obj (as result) is returned unchanged while verification tracks its type as typeTok. Unlike coercions (1.6) and conversions (3.27), isinst never changes the actual type of an object and preserves object identity (see Partition 1).")]),e._v(" "),t("p",[e._v("如果 obj 的实际类型（不是验证者跟踪的类型）是验证者可分配给类型 typeTok 的，那么 isinst 成功并且 obj（作为结果）原封不动地返回，而验证将其类型跟踪为 typeTok。与强制转换 (1.6) 和转换 (3.27) 不同，isinst 从不更改对象的实际类型并保留对象标识（参见第 1 部分）。")]),e._v(" "),t("p",[e._v("If obj is null, or obj is not verifier-assignable-to the type typeTok, isinst fails and returns null.")]),e._v(" "),t("p",[e._v("如果 obj 为 null，或者 obj 不是可分配给类型 typeTok 的验证器，则 isinst 失败并返回 null。")]),e._v(" "),t("p",[t("strong",[e._v("Exceptions:")])]),e._v(" "),t("p",[e._v("System.TypeLoadException is thrown if typeTok cannot be found. This is typically detected when CIL is converted to native code rather than at runtime.")]),e._v(" "),t("p",[t("strong",[e._v("Correctness:")])]),e._v(" "),t("p",[e._v("Correct CIL ensures that typeTok is a valid typeref or typedef or typespec token, and that obj is always either null or an object reference.")]),e._v(" "),t("p",[e._v("正确的 CIL 确保 typeTok 是有效的 typeref 或 typedef 或 typespec 标记，并且 obj 始终为 null 或对象引用。")]),e._v(" "),t("p",[t("strong",[e._v("Verifiability:")])]),e._v(" "),t("p",[e._v("Verification tracks the type of result as typeTok.")]),e._v(" "),t("p",[e._v("验证将结果类型跟踪为 typeTok。")]),e._v(" "),t("h3",{attrs:{id:"_4-7-ldelem-load-element-from-array"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-ldelem-load-element-from-array"}},[e._v("#")]),e._v(" 4.7 ldelem - load element from array")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Assembly Format")]),e._v(" "),t("th",[e._v("Description")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("A3<T>")]),e._v(" "),t("td",[e._v("ldelem typeTok")]),e._v(" "),t("td",[e._v("Load the element at index onto the top of the stack.")])])])]),e._v(" "),t("p",[t("strong",[e._v("Stack Transition:")])]),e._v(" "),t("p",[e._v("..., array, index -> ..., value")]),e._v(" "),t("p",[t("strong",[e._v("Description:")])]),e._v(" "),t("p",[e._v("The ldelem instruction loads the value of the element with index index (of type native int or int32) in the zero-based one-dimensional array array, and places it on the top of the stack. The type of the return value is indicated by the type token in the instruction.")]),e._v(" "),t("p",[e._v("ldelem 指令加载从零开始的一维数组数组中具有索引索引（本机 int 或 int32 类型）的元素的值，并将其放在堆栈顶部。 返回值的类型由指令中的类型标记指示。")])])}),[],!1,null,null,null);t.default=i.exports}}]);